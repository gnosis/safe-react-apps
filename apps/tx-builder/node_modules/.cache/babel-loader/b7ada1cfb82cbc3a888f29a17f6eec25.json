{"ast":null,"code":"import axios from 'axios';\nimport memoize from 'lodash/memoize';\nconst getAbi = memoize(async apiUrl => axios.get(apiUrl));\nconst abiUrlGetterByNetwork = {\n  MAINNET: address => `https://api.etherscan.io/api?module=contract&action=getabi&address=${address}`,\n  MORDEN: null,\n  RINKEBY: address => `https://api-rinkeby.etherscan.io/api?module=contract&action=getabi&address=${address}`,\n  ROPSTEN: null,\n  GOERLI: null,\n  KOVAN: null,\n  XDAI: address => `https://blockscout.com/poa/xdai/api?module=contract&action=getabi&address=${address}`,\n  ENERGY_WEB_CHAIN: address => `https://explorer.energyweb.org/api?module=contract&action=getabi&address=${address}`,\n  VOLTA: address => `https://volta-explorer.energyweb.org/api?module=contract&action=getabi&address=${address}`,\n  UNKNOWN: null\n};\n\nclass InterfaceRepository {\n  constructor(network, web3) {\n    this.network = void 0;\n    this.web3 = void 0;\n\n    this._isMethodPayable = m => m.payable || m.stateMutability === 'payable';\n\n    this.network = network;\n    this.web3 = web3;\n  }\n\n  async _loadAbiFromBlockExplorer(address) {\n    const getAbiUrl = abiUrlGetterByNetwork[this.network];\n\n    if (!getAbiUrl) {\n      throw Error(`Network: ${this.network} not supported.`);\n    }\n\n    const abi = await getAbi(getAbiUrl(address));\n    if (abi.data.status !== '1') throw Error(`Request not successful: ${abi.data.message}; ${abi.data.result}.`);\n    return abi.data.result;\n  }\n\n  async loadAbi(addressOrAbi) {\n    const abiString = this.web3.utils.isAddress(addressOrAbi) ? await this._loadAbiFromBlockExplorer(addressOrAbi) : addressOrAbi;\n    const abi = JSON.parse(abiString);\n    console.log('ABI');\n    const methods = abi.filter(e => {\n      if (['pure', 'view'].includes(e.stateMutability)) {\n        return false;\n      }\n\n      if ((e === null || e === void 0 ? void 0 : e.type.toLowerCase()) === 'event') {\n        return false;\n      }\n\n      return !e.constant;\n    }).map(m => {\n      return {\n        inputs: m.inputs || [],\n        name: m.name || (m.type === 'fallback' ? 'fallback' : 'receive'),\n        payable: this._isMethodPayable(m)\n      };\n    });\n    const payableFallback = abi.findIndex(e => e.type === 'fallback' && this._isMethodPayable(e)) >= 0;\n    return {\n      payableFallback,\n      methods\n    };\n  }\n\n}\n\nexport default InterfaceRepository;","map":{"version":3,"sources":["/Users/mdastugu/Projects/safe-react-apps/apps/tx-builder/src/hooks/useServices/interfaceRepository.ts"],"names":["axios","memoize","getAbi","apiUrl","get","abiUrlGetterByNetwork","MAINNET","address","MORDEN","RINKEBY","ROPSTEN","GOERLI","KOVAN","XDAI","ENERGY_WEB_CHAIN","VOLTA","UNKNOWN","InterfaceRepository","constructor","network","web3","_isMethodPayable","m","payable","stateMutability","_loadAbiFromBlockExplorer","getAbiUrl","Error","abi","data","status","message","result","loadAbi","addressOrAbi","abiString","utils","isAddress","JSON","parse","console","log","methods","filter","e","includes","type","toLowerCase","constant","map","inputs","name","payableFallback","findIndex"],"mappings":"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","sourcesContent":["import axios from 'axios';\nimport memoize from 'lodash/memoize';\nimport { Networks } from '@gnosis.pm/safe-apps-sdk';\n\ninterface ContractMethod {\n  inputs: any[];\n  name: string;\n  payable: boolean;\n}\n\nexport interface ContractInterface {\n  payableFallback: boolean;\n  methods: ContractMethod[];\n}\n\nconst getAbi = memoize(async (apiUrl: string) => axios.get(apiUrl));\n\nconst abiUrlGetterByNetwork: {\n  [key in Networks]?: ((address: string) => string) | null;\n} = {\n  MAINNET: (address: string) => `https://api.etherscan.io/api?module=contract&action=getabi&address=${address}`,\n  MORDEN: null,\n  RINKEBY: (address: string) => `https://api-rinkeby.etherscan.io/api?module=contract&action=getabi&address=${address}`,\n  ROPSTEN: null,\n  GOERLI: null,\n  KOVAN: null,\n  XDAI: (address: string) => `https://blockscout.com/poa/xdai/api?module=contract&action=getabi&address=${address}`,\n  ENERGY_WEB_CHAIN: (address: string) =>\n    `https://explorer.energyweb.org/api?module=contract&action=getabi&address=${address}`,\n  VOLTA: (address: string) =>\n    `https://volta-explorer.energyweb.org/api?module=contract&action=getabi&address=${address}`,\n  UNKNOWN: null,\n};\n\nclass InterfaceRepository {\n  network: Networks;\n  web3: any;\n\n  constructor(network: Networks, web3: any) {\n    this.network = network;\n    this.web3 = web3;\n  }\n\n  private async _loadAbiFromBlockExplorer(address: string): Promise<string> {\n    const getAbiUrl = abiUrlGetterByNetwork[this.network];\n    if (!getAbiUrl) {\n      throw Error(`Network: ${this.network} not supported.`);\n    }\n\n    const abi = await getAbi(getAbiUrl(address));\n    if (abi.data.status !== '1') throw Error(`Request not successful: ${abi.data.message}; ${abi.data.result}.`);\n    return abi.data.result;\n  }\n\n  private _isMethodPayable = (m: any) => m.payable || m.stateMutability === 'payable';\n\n  async loadAbi(addressOrAbi: string): Promise<ContractInterface> {\n    const abiString = this.web3.utils.isAddress(addressOrAbi)\n      ? await this._loadAbiFromBlockExplorer(addressOrAbi)\n      : addressOrAbi;\n\n    const abi = JSON.parse(abiString);\n    console.log('ABI')\n    const methods = abi\n      .filter((e: any) => {\n        if (['pure', 'view'].includes(e.stateMutability)) {\n          return false;\n        }\n\n        if (e?.type.toLowerCase() === 'event') {\n          return false;\n        }\n\n        return !e.constant;\n      })\n      .map((m: any) => {\n        return {\n          inputs: m.inputs || [],\n          name: m.name || (m.type === 'fallback' ? 'fallback' : 'receive'),\n          payable: this._isMethodPayable(m),\n        };\n      });\n\n    const payableFallback = abi.findIndex((e: any) => e.type === 'fallback' && this._isMethodPayable(e)) >= 0;\n\n    return { payableFallback, methods };\n  }\n}\n\nexport type InterfaceRepo = InstanceType<typeof InterfaceRepository>;\n\nexport default InterfaceRepository;\n"]},"metadata":{},"sourceType":"module"}