{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, privateMap, value) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to set private field on non-instance\");\n  }\n\n  privateMap.set(receiver, value);\n  return value;\n};\n\nvar __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, privateMap) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to get private field on non-instance\");\n  }\n\n  return privateMap.get(receiver);\n};\n\nvar _txServiceUrl, _communicator;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TXs = void 0;\n\nconst methods_1 = require(\"../communication/methods\");\n\nclass TXs {\n  constructor(communicator) {\n    _txServiceUrl.set(this, null);\n\n    _communicator.set(this, void 0);\n\n    __classPrivateFieldSet(this, _communicator, communicator);\n  }\n\n  getBySafeTxHash(safeTxHash) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!__classPrivateFieldGet(this, _txServiceUrl)) {\n        throw new Error(\"ENV information hasn't been synced yet or there was an error during the process\");\n      }\n\n      const controller = new AbortController();\n      const options = {\n        method: 'GET',\n        signal: controller.signal\n      };\n      setTimeout(() => controller.abort(), 10000);\n\n      try {\n        const res = yield fetch(`${__classPrivateFieldGet(this, _txServiceUrl)}/transactions/${safeTxHash}`, options);\n\n        if (res.status !== 200) {\n          throw new Error(\"Failed to get the transaction. Either safeTxHash is incorrect or transaction hasn't been indexed by the service yet\");\n        }\n\n        const json = yield res.json();\n        return json;\n      } catch (err) {\n        throw err;\n      }\n    });\n  }\n\n  send({\n    txs,\n    params\n  }) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!txs || !txs.length) {\n        throw new Error('No transactions were passed');\n      }\n\n      const messagePayload = {\n        txs,\n        params\n      };\n      const response = yield __classPrivateFieldGet(this, _communicator).send(methods_1.METHODS.sendTransactions, messagePayload);\n\n      if (!response.success) {\n        throw new Error(response.error);\n      }\n\n      return response.data;\n    });\n  }\n\n  setTxServiceUrl(url) {\n    __classPrivateFieldSet(this, _txServiceUrl, url);\n  }\n\n}\n\nexports.TXs = TXs;\n_txServiceUrl = new WeakMap(), _communicator = new WeakMap();","map":{"version":3,"sources":["../../../src/txs/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,MAAA,SAAA,GAAA,OAAA,CAAA,0BAAA,CAAA;;AAGA,MAAM,GAAN,CAAS;AAIP,EAAA,WAAA,CAAY,YAAZ,EAAsC;AAHtC,IAAA,aAAA,CAAA,GAAA,CAAA,IAAA,EAA+B,IAA/B;;AACA,IAAA,aAAA,CAAA,GAAA,CAAA,IAAA,EAAA,KAAA,CAAA;;AAGE,IAAA,sBAAA,CAAA,IAAA,EAAI,aAAJ,EAAqB,YAArB,CAAA;AACD;;AAEK,EAAA,eAAe,CAAC,UAAD,EAAmB;;AACtC,UAAI,CAAA,sBAAA,CAAA,IAAA,EAAA,aAAA,CAAJ,EAAyB;AACvB,cAAM,IAAI,KAAJ,CAAU,iFAAV,CAAN;AACD;;AAED,YAAM,UAAU,GAAG,IAAI,eAAJ,EAAnB;AACA,YAAM,OAAO,GAAG;AACd,QAAA,MAAM,EAAE,KADM;AAEd,QAAA,MAAM,EAAE,UAAU,CAAC;AAFL,OAAhB;AAIA,MAAA,UAAU,CAAC,MAAM,UAAU,CAAC,KAAX,EAAP,EAA2B,KAA3B,CAAV;;AAEA,UAAI;AACF,cAAM,GAAG,GAAG,MAAM,KAAK,CAAC,GAAG,sBAAA,CAAA,IAAA,EAAA,aAAA,CAAkB,iBAAiB,UAAU,EAAjD,EAAqD,OAArD,CAAvB;;AACA,YAAI,GAAG,CAAC,MAAJ,KAAe,GAAnB,EAAwB;AACtB,gBAAM,IAAI,KAAJ,CACJ,qHADI,CAAN;AAGD;;AAED,cAAM,IAAI,GAAG,MAAM,GAAG,CAAC,IAAJ,EAAnB;AAEA,eAAO,IAAP;AACD,OAXD,CAWE,OAAO,GAAP,EAAY;AACZ,cAAM,GAAN;AACD;AACF,K;AAAA;;AAEK,EAAA,IAAI,CAAC;AAAE,IAAA,GAAF;AAAO,IAAA;AAAP,GAAD,EAAsC;;AAC9C,UAAI,CAAC,GAAD,IAAQ,CAAC,GAAG,CAAC,MAAjB,EAAyB;AACvB,cAAM,IAAI,KAAJ,CAAU,6BAAV,CAAN;AACD;;AAED,YAAM,cAAc,GAAG;AACrB,QAAA,GADqB;AAErB,QAAA;AAFqB,OAAvB;AAKA,YAAM,QAAQ,GAAG,MAAM,sBAAA,CAAA,IAAA,EAAA,aAAA,CAAA,CAAmB,IAAnB,CACrB,SAAA,CAAA,OAAA,CAAQ,gBADa,EAErB,cAFqB,CAAvB;;AAKA,UAAI,CAAC,QAAQ,CAAC,OAAd,EAAuB;AACrB,cAAM,IAAI,KAAJ,CAAU,QAAQ,CAAC,KAAnB,CAAN;AACD;;AAED,aAAO,QAAQ,CAAC,IAAhB;AACD,K;AAAA;;AAEM,EAAA,eAAe,CAAC,GAAD,EAAY;AAChC,IAAA,sBAAA,CAAA,IAAA,EAAI,aAAJ,EAAqB,GAArB,CAAA;AACD;;AA5DM;;AA+DA,OAAA,CAAA,GAAA,GAAA,GAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {\n    if (!privateMap.has(receiver)) {\n        throw new TypeError(\"attempted to set private field on non-instance\");\n    }\n    privateMap.set(receiver, value);\n    return value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {\n    if (!privateMap.has(receiver)) {\n        throw new TypeError(\"attempted to get private field on non-instance\");\n    }\n    return privateMap.get(receiver);\n};\nvar _txServiceUrl, _communicator;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TXs = void 0;\nconst methods_1 = require(\"../communication/methods\");\nclass TXs {\n    constructor(communicator) {\n        _txServiceUrl.set(this, null);\n        _communicator.set(this, void 0);\n        __classPrivateFieldSet(this, _communicator, communicator);\n    }\n    getBySafeTxHash(safeTxHash) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!__classPrivateFieldGet(this, _txServiceUrl)) {\n                throw new Error(\"ENV information hasn't been synced yet or there was an error during the process\");\n            }\n            const controller = new AbortController();\n            const options = {\n                method: 'GET',\n                signal: controller.signal,\n            };\n            setTimeout(() => controller.abort(), 10000);\n            try {\n                const res = yield fetch(`${__classPrivateFieldGet(this, _txServiceUrl)}/transactions/${safeTxHash}`, options);\n                if (res.status !== 200) {\n                    throw new Error(\"Failed to get the transaction. Either safeTxHash is incorrect or transaction hasn't been indexed by the service yet\");\n                }\n                const json = yield res.json();\n                return json;\n            }\n            catch (err) {\n                throw err;\n            }\n        });\n    }\n    send({ txs, params }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!txs || !txs.length) {\n                throw new Error('No transactions were passed');\n            }\n            const messagePayload = {\n                txs,\n                params,\n            };\n            const response = yield __classPrivateFieldGet(this, _communicator).send(methods_1.METHODS.sendTransactions, messagePayload);\n            if (!response.success) {\n                throw new Error(response.error);\n            }\n            return response.data;\n        });\n    }\n    setTxServiceUrl(url) {\n        __classPrivateFieldSet(this, _txServiceUrl, url);\n    }\n}\nexports.TXs = TXs;\n_txServiceUrl = new WeakMap(), _communicator = new WeakMap();\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}