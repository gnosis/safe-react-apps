{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useState, useCallback, useEffect } from 'react';\nimport WalletConnect from '@walletconnect/client';\nimport { useSafeAppsSDK } from '@gnosis.pm/safe-apps-react-sdk';\nimport { chainIdByNetwork } from '../utils/networks';\nimport { encodeSignMessageCall } from '../utils/signatures';\nimport { isMetaTxArray } from '../utils/transactions';\nimport { areStringsEqual } from '../utils/strings';\nexport const LOCAL_STORAGE_URI_KEY = 'safeAppWcUri';\n\nconst rejectWithMessage = (connector, id, message) => {\n  connector.rejectRequest({\n    id,\n    error: {\n      message\n    }\n  });\n};\n\nconst useWalletConnect = () => {\n  _s();\n\n  const {\n    safe,\n    sdk\n  } = useSafeAppsSDK();\n  const [wcClientData, setWcClientData] = useState(null);\n  const [connector, setConnector] = useState();\n  const wcDisconnect = useCallback(async () => {\n    connector === null || connector === void 0 ? void 0 : connector.killSession();\n    localStorage.removeItem(LOCAL_STORAGE_URI_KEY);\n    setConnector(undefined);\n    setWcClientData(null);\n  }, [connector]);\n  const wcConnect = useCallback(async uri => {\n    const network = safe.network;\n    const wcConnector = new WalletConnect({\n      uri\n    });\n    setConnector(wcConnector);\n    setWcClientData(wcConnector.peerMeta);\n    localStorage.setItem(LOCAL_STORAGE_URI_KEY, uri);\n    wcConnector.on('session_request', (error, payload) => {\n      if (error) {\n        throw error;\n      }\n\n      wcConnector.approveSession({\n        accounts: [safe.safeAddress],\n        chainId: chainIdByNetwork[network]\n      });\n      setWcClientData(payload.params[0].peerMeta);\n    });\n    wcConnector.on('call_request', async (error, payload) => {\n      if (error) {\n        throw error;\n      }\n\n      try {\n        let result = '0x';\n\n        switch (payload.method) {\n          case 'eth_sendTransaction':\n            {\n              const txInfo = payload.params[0];\n              const {\n                safeTxHash\n              } = await sdk.txs.send({\n                txs: [{\n                  to: txInfo.to,\n                  value: txInfo.value || '0x0',\n                  data: txInfo.data || '0x'\n                }]\n              });\n              result = safeTxHash;\n              break;\n            }\n\n          case 'gs_multi_send':\n            {\n              const txs = payload.params;\n\n              if (!isMetaTxArray(txs)) {\n                throw new Error('INVALID_TRANSACTIONS_PROVIDED');\n              }\n\n              const {\n                safeTxHash\n              } = await sdk.txs.send({\n                txs: txs.map(txInfo => ({\n                  to: txInfo.to,\n                  value: (txInfo.value || '0x0').toString(),\n                  data: txInfo.data || '0x'\n                }))\n              });\n              result = safeTxHash;\n              break;\n            }\n\n          case 'eth_sign':\n            {\n              const [address, messageHash] = payload.params;\n\n              if (!areStringsEqual(address, safe.safeAddress) || !messageHash.startsWith('0x')) {\n                throw new Error('The address or message hash is invalid');\n              }\n\n              const callData = encodeSignMessageCall(messageHash);\n              await sdk.txs.send({\n                txs: [{\n                  to: safe.safeAddress,\n                  value: '0x0',\n                  data: callData\n                }]\n              });\n              break;\n            }\n\n          default:\n            {\n              rejectWithMessage(wcConnector, payload.id, 'METHOD_NOT_SUPPORTED');\n              break;\n            }\n        }\n\n        wcConnector.approveRequest({\n          id: payload.id,\n          result\n        });\n      } catch (err) {\n        rejectWithMessage(wcConnector, payload.id, err.message);\n      }\n    });\n    wcConnector.on('disconnect', (error, payload) => {\n      if (error) {\n        throw error;\n      }\n\n      wcDisconnect();\n    });\n  }, [safe, sdk, wcDisconnect]);\n  useEffect(() => {\n    if (!connector) {\n      const uri = localStorage.getItem(LOCAL_STORAGE_URI_KEY);\n      if (uri) wcConnect(uri);\n    }\n  }, [connector, wcConnect]);\n  return {\n    wcClientData,\n    wcConnect,\n    wcDisconnect\n  };\n};\n\n_s(useWalletConnect, \"f0m+iiQ9SWC4yzBZD+fjjByIoXU=\", false, function () {\n  return [useSafeAppsSDK];\n});\n\nexport default useWalletConnect;","map":{"version":3,"sources":["/Users/mdastugu/Projects/safe-react-apps/apps/wallet-connect/src/hooks/useWalletConnect.tsx"],"names":["useState","useCallback","useEffect","WalletConnect","useSafeAppsSDK","chainIdByNetwork","encodeSignMessageCall","isMetaTxArray","areStringsEqual","LOCAL_STORAGE_URI_KEY","rejectWithMessage","connector","id","message","rejectRequest","error","useWalletConnect","safe","sdk","wcClientData","setWcClientData","setConnector","wcDisconnect","killSession","localStorage","removeItem","undefined","wcConnect","uri","network","wcConnector","peerMeta","setItem","on","payload","approveSession","accounts","safeAddress","chainId","params","result","method","txInfo","safeTxHash","txs","send","to","value","data","Error","map","toString","address","messageHash","startsWith","callData","approveRequest","err","getItem"],"mappings":"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","sourcesContent":["import { useState, useCallback, useEffect } from 'react';\nimport WalletConnect from '@walletconnect/client';\nimport { IClientMeta } from '@walletconnect/types';\nimport { useSafeAppsSDK } from '@gnosis.pm/safe-apps-react-sdk';\nimport { chainIdByNetwork } from '../utils/networks';\nimport { encodeSignMessageCall } from '../utils/signatures';\nimport { isMetaTxArray } from '../utils/transactions';\nimport { areStringsEqual } from '../utils/strings';\n\nexport const LOCAL_STORAGE_URI_KEY = 'safeAppWcUri';\n\nconst rejectWithMessage = (connector: WalletConnect, id: number | undefined, message: string) => {\n  connector.rejectRequest({ id, error: { message } });\n};\n\nconst useWalletConnect = () => {\n  const { safe, sdk } = useSafeAppsSDK();\n  const [wcClientData, setWcClientData] = useState<IClientMeta | null>(null);\n  const [connector, setConnector] = useState<WalletConnect | undefined>();\n\n  const wcDisconnect = useCallback(async () => {\n    connector?.killSession();\n    localStorage.removeItem(LOCAL_STORAGE_URI_KEY);\n    setConnector(undefined);\n    setWcClientData(null);\n  }, [connector]);\n\n  const wcConnect = useCallback(\n    async (uri: string) => {\n      const network = safe.network;\n\n      const wcConnector = new WalletConnect({ uri });\n      setConnector(wcConnector);\n      setWcClientData(wcConnector.peerMeta);\n      localStorage.setItem(LOCAL_STORAGE_URI_KEY, uri);\n\n      wcConnector.on('session_request', (error, payload) => {\n        if (error) {\n          throw error;\n        }\n\n        wcConnector.approveSession({\n          accounts: [safe.safeAddress],\n          chainId: chainIdByNetwork[network],\n        });\n\n        setWcClientData(payload.params[0].peerMeta);\n      });\n\n      wcConnector.on('call_request', async (error, payload) => {\n        if (error) {\n          throw error;\n        }\n\n        try {\n          let result = '0x';\n\n          switch (payload.method) {\n            case 'eth_sendTransaction': {\n              const txInfo = payload.params[0];\n              const { safeTxHash } = await sdk.txs.send({\n                txs: [\n                  {\n                    to: txInfo.to,\n                    value: txInfo.value || '0x0',\n                    data: txInfo.data || '0x',\n                  },\n                ],\n              });\n\n              result = safeTxHash;\n              break;\n            }\n            case 'gs_multi_send': {\n              const txs = payload.params;\n\n              if (!isMetaTxArray(txs)) {\n                throw new Error('INVALID_TRANSACTIONS_PROVIDED');\n              }\n\n              const { safeTxHash } = await sdk.txs.send({\n                txs: txs.map((txInfo) => ({\n                  to: txInfo.to,\n                  value: (txInfo.value || '0x0').toString(),\n                  data: txInfo.data || '0x',\n                })),\n              });\n\n              result = safeTxHash;\n              break;\n            }\n\n            case 'eth_sign': {\n              const [address, messageHash] = payload.params;\n\n              if (!areStringsEqual(address, safe.safeAddress) || !messageHash.startsWith('0x')) {\n                throw new Error('The address or message hash is invalid');\n              }\n\n              const callData = encodeSignMessageCall(messageHash);\n              await sdk.txs.send({\n                txs: [\n                  {\n                    to: safe.safeAddress,\n                    value: '0x0',\n                    data: callData,\n                  },\n                ],\n              });\n              break;\n            }\n            default: {\n              rejectWithMessage(wcConnector, payload.id, 'METHOD_NOT_SUPPORTED');\n              break;\n            }\n          }\n\n          wcConnector.approveRequest({\n            id: payload.id,\n            result,\n          });\n        } catch (err) {\n          rejectWithMessage(wcConnector, payload.id, err.message);\n        }\n      });\n\n      wcConnector.on('disconnect', (error, payload) => {\n        if (error) {\n          throw error;\n        }\n        wcDisconnect();\n      });\n    },\n    [safe, sdk, wcDisconnect],\n  );\n\n  useEffect(() => {\n    if (!connector) {\n      const uri = localStorage.getItem(LOCAL_STORAGE_URI_KEY);\n      if (uri) wcConnect(uri);\n    }\n  }, [connector, wcConnect]);\n\n  return { wcClientData, wcConnect, wcDisconnect };\n};\n\nexport default useWalletConnect;\n"]},"metadata":{},"sourceType":"module"}